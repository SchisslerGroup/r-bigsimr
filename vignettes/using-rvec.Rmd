---
title: "Overview of using bigsimr"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Overview of using bigsimr}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(bigsimr)
```

# Basics

This package operates on the principle of Gaussian copulas, for which you will need a list of target marginal distributions and a correlation structure between the margins.

The main function is `bigsimr::rvec` which mirrors some of the conventions found in the base `stats` package like `stats::rnorm`. I.e. the common convention for generating a random vector is to first specify the number of samples followed by the parameters for the distribution.


```{r}
# To generate normally distributed samples, three things are needed:
#   1) The number of samples to generate
#   2) The location of the normal distribution (mean)
#   3) The scale of the normal distribution (standard deviation)
rnorm(n = 16, mean = 5, sd = 1.5)
```


The function `rvec` behaves similarly. It takes in as arguments the number of samples to generate, a correlation matrix, and a list of margins. The parameters of the margins can be arbitrary and the correlation matrix can take on values within a broad range constrained by the theoretical bounds. In the following sections we will go through the basic usage of `bigsimr` and the functionality within.

# Building a Multivariate Distribution

As stated earlier, to generate multivariate data, we need a list of marginals (and their parameters), and a correlation structure (matrix). The marginal distributions can be built up using R's special `alist` function. This allows one to enter the distributions without evaluating anything (yet).

```{r}
margins <- alist(
  qnorm(mean = 3.14, sd = 0.1),
  qbeta(shape1 = 1, shape2 = 4),
  qnbinom(size = 10, prob = 0.75)
)
```

Notice that we use the *quantile* function for the marginals, as that is the workhorse of the `rvec` function. By using an `alist`, users can also specify their own custom distributions. **It is highly recommended that users follow R's naming convention for probability distributions**. I.e. prefixing distributions with `r` and `q`. In the future we hope to be able to handle any arbitrary function name. If one wishes to compute the theoretical correlation bounds, then one should also specify the RNG function for their custom distribution. For example, R does not have any functions for the *Pareto* distribution. We can write a quantile and RNG function as follows:

The Pareto CDF is defined as

$$
1 - \left(\frac{x_m}{x}\right)^\alpha
$$

for $x_m > 0$ scale and $\alpha > 0$ shape, with support $x \in \left[x_m, \infty\right)$. From the CDF, we compute the inverse CDF

$$
\frac{x_m}{\left(1 - p\right)^\frac{1}{\alpha}}
$$

```{r}
qpareto <- function(p, scale, shape) {
  scale / (1 - p)^(1/shape)
}
```

Writing a RNG function for our new distribution can be accomplished by calling the quantile function on the output of a unit uniform distribution.

```{r}
rpareto <- function(n, scale, shape) {
  qpareto(runif(n), scale, shape)
}
```

The new distribution can then be used in the list of marginals.

```{r}
margins <- alist(
  qnorm(mean = 3.14, sd = 0.1),
  qbeta(shape1 = 1, shape2 = 4),
  qnbinom(size = 10, prob = 0.75),
  qpareto(scale = 1.11, shape = 5.55)
)
```


The next step is to define a correlation structure for the multivariate distribution. This correlation matrix can either come from observed data, or we can set it ourselves, or we can generate a random correlation matrix via `bigsimr::cor_randPSD`. Since we have 4 marginals, we need a $4\times 4$ matrix.

```{r}
set.seed(12)
# rho <- bigsimr::cor_randPD(4)
rho <- bigsimr::cor_randPSD(4)
```

```{r, echo=FALSE}
round(rho, 3)
```


Finally we can generate a random vector with our specified marginals and correlation structure. The last argument, `type`, is looking to know what kind of correlation matrix it is receiving. Right now it can handle Pearson, Spearman, or Kendall.

If you have the CPU version of JAX installed, you may see an error similar to `warning.warn('No GPU/TPU found, falling back to CPU.')`. This message indicates that JAX is running on the CPU rather than a GPU/TPU.

```{r}
x <- bigsimr::rvec(10, rho = rho, margins = margins, type = "pearson")
```

Taking a look at our random vector, we see that it has 10 rows and 4 columns, one column for each marginal distribution.

```{r}
x
```

We can simulate many more samples and then check the histogram of each margin, as well as the estimated correlation between the columns.

```{r}
x <- bigsimr::rvec(10000, rho = rho, margins = margins, type = "pearson")
```

```{r, echo=FALSE}
hist(x[,1], breaks = 30, xlab = "", main = "Normal")
hist(x[,2], breaks = 30, xlab = "", main = "Beta")
hist(x[,3], breaks = 30, xlab = "", main = "Negative Binomial")
hist(x[,4], breaks = 30, xlab = "", main = "Pareto")
```

```{r}
round(bigsimr::cor_fast(x, method = "pearson"), 2)
```

```{r}
round(rho, 2)
```

We can see that even with 10,000 samples, the estimated correlation of the simulated data is not exactly the same as the target correlation. This can be explained by the fact that some correlations are simply not possible due to the discrete nature of certain distributions.

We can check the theoretical correlation bounds in bigsimr

```{r}
bigsimr::cor_bounds(margins, type = "pearson")
```


# Appendix

```{r, eval=FALSE}
all_dists <- alist(
  qbeta( shape1, shape2 ),
  qbinom( size, prob ),
  qcauchy( location, scale ),
  qchisq( df ),
  qexp( rate ),
  qf( df1, df2 ),
  qgamma( shape, rate ),
  qgeom( prob ),
  qhyper( m, n, k ),
  qlogis( location, scale ),
  qlnorm( meanlog, sdlog ),
  qnbinom( size, prob ),
  qnorm( mean, sd ),
  qpois( lambda ),
  qt( df ),
  qunif( min, max ),
  qweibull( shape, scale ),
  qwilcox( m, n ),
  qsignrank( n )
)
```
